# Dokumentacja KontrolerÃ³w

## Spis treÅ›ci
1. [Wprowadzenie](#wprowadzenie)
2. [Organizacja KatalogÃ³w](#organizacja-katalogÃ³w)
3. [Struktura Kontrolera](#struktura-kontrolera)
4. [Typy KontrolerÃ³w](#typy-kontrolerÃ³w)
4. [Konfiguracja Routingu](#konfiguracja-routingu)
5. [Atrybuty OpenAPI](#atrybuty-openapi)
6. [Rozszerzanie FunkcjonalnoÅ›ci](#rozszerzanie-funkcjonalnoÅ›ci)
7. [PrzykÅ‚ady Implementacji](#przykÅ‚ady-implementacji)
8. [Tworzenie kontrolera krok po kroku ](#tworzenie-kontrolera---krok-po-kroku)

## Wprowadzenie

Kontrolery w systemie Wise peÅ‚niÄ… kluczowÄ… rolÄ™ jako pierwszy punkt kontaktu dla Å¼Ä…daÅ„ API. KaÅ¼dy kontroler jest odpowiedzialny za obsÅ‚ugÄ™ okreÅ›lonego zestawu operacji zwiÄ…zanych z danymi. Dokumentacja ta przedstawia strukturÄ™ kontrolerÃ³w, ich funkcje oraz zasady ich implementacji w systemie Wise.

## Organizacja KatalogÃ³w

### Struktura ModuÅ‚Ã³w

W systemie Wise kontrolery naleÅ¼y umieszczaÄ‡ wedÅ‚ug nastÄ™pujÄ…cej struktury katalogÃ³w:

```
ModuÅ‚Projektu/
â”œâ”€â”€ ApiUi/                  # Dla endpointÃ³w UI API
â”‚   â””â”€â”€ Controller/         # Kontrolery UI API
â”‚       â”œâ”€â”€ Feature1/       # Grupowanie kontrolerÃ³w wedÅ‚ug funkcjonalnoÅ›ci
â”‚       â””â”€â”€ Feature2/
â””â”€â”€ ApiAdmin/              # Dla endpointÃ³w Admin API
    â””â”€â”€ Controller/        # Kontrolery Admin API
        â”œâ”€â”€ Feature1/      # Grupowanie kontrolerÃ³w wedÅ‚ug funkcjonalnoÅ›ci
        â””â”€â”€ Feature2/
```

### Zasady Organizacji

1. W zaleÅ¼noÅ›ci od typu endpointu, naleÅ¼y utworzyÄ‡ odpowiedni katalog gÅ‚Ã³wny:
   - `ApiUi` - dla endpointÃ³w interfejsu uÅ¼ytkownika (frontend B2B)
   - `ApiAdmin` - dla endpointÃ³w administracyjnych (integracja z ERP)

2. W kaÅ¼dym z tych katalogÃ³w naleÅ¼y utworzyÄ‡ podkatalog `Controller`

3. Kontrolery moÅ¼na dodatkowo grupowaÄ‡ w podkatalogi wedÅ‚ug funkcjonalnoÅ›ci

### PrzykÅ‚adowa Struktura

```
Agreement/
â”œâ”€â”€ ApiUi/
â”‚   â””â”€â”€ Controller/
â”‚       â”œâ”€â”€ Contract/
â”‚       â”‚   â”œâ”€â”€ GetContractsController.php
â”‚       â”‚   â””â”€â”€ UpdateContractController.php
â”‚       â””â”€â”€ Terms/
â”‚           â”œâ”€â”€ GetTermsController.php
â”‚           â””â”€â”€ AcceptTermsController.php
â””â”€â”€ ApiAdmin/
    â””â”€â”€ Controller/
        â””â”€â”€ ContractManagement/
            â”œâ”€â”€ PutContractController.php
            â””â”€â”€ GetContractListController.php
```

 pierwszy punkt kontaktu, od ktÃ³rego rozpoczyna siÄ™ droga zwrÃ³cenia/wykonania operacji za pomocÄ… endpointÃ³w. System Wise rozrÃ³Å¼nia dwa gÅ‚Ã³wne typy API:

- **UI API** - endpointy wykonywane na froncie aplikacji (witryny B2B). Wszystko co jest widoczne i funkcjonalne na witrynie to wÅ‚aÅ›nie UI API.
- **Admin API** - endpointy sÅ‚uÅ¼Ä…ce do integracji danych (np. z systemu ERP do systemu B2B). SÄ… to gÅ‚Ã³wnie operacje CRUD na encjach.

## Struktura Kontrolera

### Podstawowe Wymagania

KaÅ¼dy kontroler w systemie Wise musi speÅ‚niaÄ‡ nastÄ™pujÄ…ce wymagania:

1. **Dziedziczenie** - kaÅ¼dy kontroler musi dziedziczyÄ‡ po odpowiednim Abstract (szczegÃ³Å‚y w sekcji Typy KontrolerÃ³w)
2. **Konstruktor** musi zawieraÄ‡ dwie kluczowe zaleÅ¼noÅ›ci:
   - `ControllerShareMethodsHelperInterface` - serwis udostÄ™pniajÄ…cy dodatkowe funkcjonalnoÅ›ci we wszystkich kontrolerach bez potrzeby modyfikacji wszystkich endpointÃ³w
   - Serwis prezentacji specyficzny dla danego endpointu

### Dlaczego Dziedziczenie jest WaÅ¼ne?

Dziedziczenie po odpowiednich klasach abstrakcyjnych jest kluczowe z nastÄ™pujÄ…cych powodÃ³w:

1. Automatyczna detekcja typu API (Admin API vs UI API)
2. Odpowiednia obsÅ‚uga uwierzytelnienia i bÅ‚Ä™dÃ³w w zaleÅ¼noÅ›ci od typu API
3. Standaryzacja przekazywania danych do serwisÃ³w prezentacji
4. Zapewnienie poprawnej obsÅ‚ugi DTO dla odpowiedzi zgodnie z dokumentacjÄ… OpenAPI

## Typy KontrolerÃ³w

### UI API Kontrolery

| Operacja | Klasa Bazowa |
|----------|--------------|
| GET (lista) | `Wise\Core\ApiUi\Controller\AbstractGetListController` |
| GET (szczegÃ³Å‚y) | `Wise\Core\ApiUi\Controller\AbstractGetDetailsController` |
| POST | `Wise\Core\ApiUi\Controller\AbstractPostController` |
| PUT | `Wise\Core\ApiUi\Controller\AbstractPutController` |
| DELETE | `Wise\Core\ApiUi\Controller\AbstractDeleteController` |

### Admin API Kontrolery

| Operacja | Klasa Bazowa |
|----------|--------------|
| GET (lista) | `Wise\Core\ApiAdmin\Controller\AbstractGetListAdminApiController` |
| GET (szczegÃ³Å‚y) | `Wise\Core\ApiAdmin\Controller\AbstractGetDetailsAdminApiController` |
| PATCH | `Wise\Core\ApiAdmin\Controller\AbstractPatchAdminApiController` |
| PUT | `Wise\Core\ApiAdmin\Controller\AbstractPutAdminApiController` |
| DELETE | `Wise\Core\ApiAdmin\Controller\AbstractDeleteAdminApiController` |

### RÃ³Å¼nica miÄ™dzy GET List a GET Details

Kluczowa rÃ³Å¼nica miÄ™dzy tymi dwoma typami endpointÃ³w GET polega na strukturze zwracanych danych:

#### GET List Response
Automatycznie zwraca dane w formacie obsÅ‚ugiwanym przez paginacjÄ™:
```json
{
  "items": [
    {
      "id": 1,
      "isActive": true,
      "requirement": 1,
      "impact": 1,
      "contexts": "HOME_PAGE;CHECKOUT",
      "symbol": "RULES_2024_11_12",
      // inne pola
    }
  ],
  "page": 1,
  "totalCount": 10,
  "totalPages": 2
}
```

#### GET Details Response
Zwraca szczegÃ³Å‚owe dane pojedynczego elementu bez struktury paginacji:
```json
{
  "id": 1,
  "isActive": true,
  "requirement": 1,
  "impact": 1,
  "contexts": "HOME_PAGE;CHECKOUT",
  "symbol": "RULES_2024_11_12",
  "type": "RULES",
  // inne pola
}
```

## Konfiguracja Routingu

### 1. Atrybut Route w Kontrolerze

KaÅ¼dy kontroler musi posiadaÄ‡ atrybut Route:
```php
#[Route(path: '/', methods: Request::METHOD_GET)]
```

### 2. Konfiguracja w routes.yaml

UWAGA! Sama deklaracja atrybutu Route nie wystarczy. Konieczna jest odpowiednia konfiguracja w pliku routes.yaml danego moduÅ‚u:

```yaml
wise_agreement_contract_api_ui_v2:
  trailing_slash_on_root: false
  resource: ../../ApiUi/Controller/Contract/
  prefix: api/ui/contract
  type: annotation
```

Gdzie:
- `resource` - Å›cieÅ¼ka do katalogu z kontrolerami
- `prefix` - prefiks dla wszystkich routingÃ³w z tego katalogu
- `type` - typ konfiguracji (annotation)

### 3. Rejestracja w Symfony

WAÅ»NE! Po utworzeniu nowego pliku routes.yaml w Resources swojego moduÅ‚u, naleÅ¼y go zarejestrowaÄ‡ w gÅ‚Ã³wnej konfiguracji Symfony, w katalogu `/config/routes.yaml`.

## Atrybuty OpenAPI

### UI API Atrybuty

| Metoda HTTP | Atrybut | Namespace |
|------------|---------|-----------|
| GET | `OAGet` | `Wise\Core\ApiUi\Attributes\OpenApi\EndpointType\OAGet` |
| POST | `OAPost` | `Wise\Core\ApiUi\Attributes\OpenApi\EndpointType\OAPost` |
| PUT | `OAPut` | `Wise\Core\ApiUi\Attributes\OpenApi\EndpointType\OAPut` |
| DELETE | `OADelete` | `Wise\Core\ApiUi\Attributes\OpenApi\EndpointType\OADelete` |

### Admin API Atrybuty

| Metoda HTTP | Atrybut | Namespace |
|------------|---------|-----------|
| GET | `OAGet` | `Wise\Core\ApiAdmin\Attributes\OpenApi\EndpointType\OAGet` |
| PATCH | `OAPatch` | `Wise\Core\ApiAdmin\Attributes\OpenApi\EndpointType\OAPatch` |
| PUT | `OAPut` | `Wise\Core\ApiAdmin\Attributes\OpenApi\EndpointType\OAPut` |
| DELETE | `OADelete` | `Wise\Core\ApiAdmin\Attributes\OpenApi\EndpointType\OADelete` |

### Konfiguracja DTO

Atrybuty OpenAPI wymagajÄ… odpowiedniej konfiguracji:

```php
#[OAGet(
    description: 'Opis endpointu',
    tags: ['NazwaGrupy'],
    responseDto: new OA\JsonContent(ref: "#/components/schemas/DtoAlias", type: "object")
)]
```

Gdzie:
- `description` - opis funkcjonalnoÅ›ci endpointu
- `tags` - grupowanie endpointÃ³w w dokumentacji OpenAPI (widoczne w Nelmio)
- `responseDto/requestDto/parametersDto` - definicja struktury danych:
  - responseDto - struktura odpowiedzi
  - requestDto - struktura body Å¼Ä…dania
  - parametersDto - struktura parametrÃ³w

#### Konfiguracja AliasÃ³w DTO

WAÅ»NE! KaÅ¼dy alias DTO musi byÄ‡ zdefiniowany w konfiguracji `config/packages/nelmio_api_doc.yaml`:

```yaml
- {
    alias: DtoAlias,
    type: Wise\Module\Path\To\Dto,
    areas: [ 'api_ui_v2' ]
  }
```

Gdzie:
- `alias` - nazwa uÅ¼ywana w atrybutach OpenAPI
- `type` - peÅ‚na Å›cieÅ¼ka do klasy DTO
- `areas` - obszar dostÄ™pnoÅ›ci (`api_ui_v2` lub `api_admin_v2`)

## Rozszerzanie FunkcjonalnoÅ›ci

### Modyfikacja Response DTO

JeÅ›li wdroÅ¼enie wymaga modyfikacji standardowej odpowiedzi (np. dodanie nowego pola), nie trzeba modyfikowaÄ‡ kontrolera. Wystarczy:

1. UtworzyÄ‡ nowÄ… klasÄ™ DTO
2. PodmieniÄ‡ konfiguracjÄ™ w `config/packages/nelmio_api_doc.yaml`:
```yaml
- {
    alias: ExistingDtoAlias,
    type: Your\New\DtoClass,
    areas: [ 'api_ui_v2' ]
  }
```

Ta konfiguracja nadpisze standardowe DTO, a system automatycznie uÅ¼yje nowej definicji podczas budowania dokumentacji OpenAPI.

## PrzykÅ‚ady Implementacji

### PrzykÅ‚ad Kontrolera GET List

```php
namespace App\Controller;

use OpenApi\Attributes as OA;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;
use Wise\Core\ApiUi\Controller\AbstractGetListController;
use Wise\Core\ApiUi\Attributes\OpenApi\EndpointType\OAGet;

class GetExampleListController extends AbstractGetListController
{
    public function __construct(
        private readonly ControllerShareMethodsHelperInterface $helper,
        private readonly ExampleServiceInterface $service
    ) {
        parent::__construct($helper, $service);
    }

    #[Route(path: '/', methods: Request::METHOD_GET)]
    #[OAGet(
        description: 'Zwraca listÄ™ przykÅ‚adowych elementÃ³w z obsÅ‚ugÄ… paginacji',
        tags: ['Example'],
        responseDto: new OA\JsonContent(ref: "#/components/schemas/ExampleListDto", type: "object")
    )]
    public function getAction(Request $request): JsonResponse
    {
        return parent::getAction($request);
    }
}
```

### PrzykÅ‚ad Kontrolera GET Details

```php
class GetExampleDetailsController extends AbstractGetDetailsController
{
    public function __construct(
        private readonly ControllerShareMethodsHelperInterface $helper,
        private readonly ExampleDetailsServiceInterface $service
    ) {
        parent::__construct($helper, $service);
    }

    #[Route(path: '/{id}', methods: Request::METHOD_GET)]
    #[OAGet(
        description: 'Pobiera szczegÃ³Å‚owe informacje o pojedynczym elemencie',
        tags: ['Example'],
        responseDto: new OA\JsonContent(ref: "#/components/schemas/ExampleDetailsDto", type: "object")
    )]
    public function getAction(Request $request): JsonResponse
    {
        return parent::getAction($request);
    }
}
```


## Tworzenie kontrolera - Krok po Kroku

### 1. WybÃ³r Typu API
Najpierw zdecyduj, czy endpoint bÄ™dzie naleÅ¼aÅ‚ do **UI API** (frontend B2B) czy **Admin API** (integracja np. z ERP).

### 2. Utworzenie Kontrolera
Wybierz odpowiedni katalog:
- `ApiUi/Controller/FeatureX/` dla UI API
- `ApiAdmin/Controller/FeatureX/` dla Admin API

NastÄ™pnie utwÃ³rz nowy plik kontrolera, np. `GetExampleListController.php`.

### 3. Dziedziczenie po Klasie Abstrakcyjnej
Wybierz odpowiedni typ kontrolera:

#### Dla UI API:
```php
use Wise\Core\ApiUi\Controller\AbstractGetListController;
```
#### Dla Admin API:
```php
use Wise\Core\ApiAdmin\Controller\AbstractGetListAdminApiController;
```

PrzykÅ‚adowa klasa kontrolera:
```php
namespace App\Controller;

use OpenApi\Attributes as OA;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;
use Wise\Core\ApiUi\Controller\AbstractGetListController;
use Wise\Core\ApiUi\Attributes\OpenApi\EndpointType\OAGet;

class GetExampleListController extends AbstractGetListController
{
    public function __construct(
        private readonly ControllerShareMethodsHelperInterface $helper,
        private readonly ExampleServiceInterface $service
    ) {
        parent::__construct($helper, $service);
    }

    #[Route(path: '/', methods: Request::METHOD_GET)]
    #[OAGet(
        description: 'Zwraca listÄ™ przykÅ‚adowych elementÃ³w z obsÅ‚ugÄ… paginacji',
        tags: ['Example'],
        responseDto: new OA\JsonContent(ref: "#/components/schemas/ExampleListDto", type: "object")
    )]
    public function getAction(Request $request): JsonResponse
    {
        return parent::getAction($request);
    }
}
```

### 4. Dodanie Routingu w `routes.yaml`
Upewnij siÄ™, Å¼e endpoint zostaÅ‚ poprawnie zarejestrowany w `routes.yaml` danego moduÅ‚u:
```yaml
wise_example_list_api_ui_v2:
  trailing_slash_on_root: false
  resource: ../../ApiUi/Controller/Example/
  prefix: api/ui/example
  type: annotation
```

### 5. Deklaracja Aliasu DTO
W pliku `config/packages/nelmio_api_doc.yaml` dodaj alias:
```yaml
- {
    alias: ExampleListDto,
    type: Wise\Module\Path\To\Dto,
    areas: [ 'api_ui_v2' ]
  }
```

DziÄ™ki temu system poprawnie zarejestruje strukturÄ™ odpowiedzi w dokumentacji OpenAPI.

### 6. Dodanie serwisu prezentacji
Dodaj serwis prezentacji do konstruktora kontrolera:
```php
public function __construct(
    private readonly ControllerShareMethodsHelperInterface $helper,
    private readonly ExampleServiceInterface $service
) {
    parent::__construct($helper, $service);
}
```



### 7. Testowanie Endpointu
Po wdroÅ¼eniu nowego endpointu warto sprawdziÄ‡ jego dziaÅ‚anie:
- UruchomiÄ‡ aplikacjÄ™ i przetestowaÄ‡ odpowiedÅº w **Postmanie** lub **Swagger UI**.
- SprawdziÄ‡ poprawnoÅ›Ä‡ DTO w dokumentacji OpenAPI.
- UpewniÄ‡ siÄ™, Å¼e endpoint zwraca poprawne dane.

---
To wszystko! Teraz TwÃ³j endpoint jest gotowy do uÅ¼ycia. ðŸš€
